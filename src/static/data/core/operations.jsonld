{"@context":"http://schema.org","@type":"CreativeWork","name":"Operations","text":"\u003ch1\u003eOperations\u003c/h1\u003e\n\n\u003cp\u003eAPI Platform Core relies on the concept of operations. Operations can be applied to a resource exposed by the API. From\nan implementation point of view, an operation is a link between a resource, a route and its related controller.\u003c/p\u003e\n\n\u003cp\u003eAPI Platform automatically registers typical \u003ca href=\"https://en.wikipedia.org/wiki/Create,_read,_update_and_delete\"\u003eCRUD\u003c/a\u003e operations\nand describes them in the exposed documentation (Hydra and NelmioApiDoc). It also creates and registers routes corresponding\nto these operations in the Symfony routing system (if it is available).\u003c/p\u003e\n\n\u003cp\u003eThe behavior of built-in operations is briefly presented in the \u003ca href=\"getting-started.jsonld#mapping-the-entities\"\u003eGetting started\u003c/a\u003e\nguide.\u003c/p\u003e\n\n\u003cp\u003eThe list of enabled operations can be configured on a per resource basis. Creating custom operations on specific routes\nis also possible.\u003c/p\u003e\n\n\u003cp\u003eThere are two types of operations: collection operations and item operations.\u003c/p\u003e\n\n\u003cp\u003eCollection operations act on a collection of resources. By default two routes are implemented: \u003ccode\u003ePOST\u003c/code\u003e and \u003ccode\u003eGET\u003c/code\u003e. Item\noperations act on an individual resource. 3 default routes are defined \u003ccode\u003eGET\u003c/code\u003e, \u003ccode\u003ePUT\u003c/code\u003e and \u003ccode\u003eDELETE\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eWhen the \u003ccode\u003eApiPlatform\\Core\\Annotation\\ApiResource\u003c/code\u003e annotation is applied to an entity class, the following built-in CRUD\noperations are automatically enabled:\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eCollection operations\u003c/em\u003e\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eMethod\u003c/th\u003e\n\u003cth\u003eMandatory\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eGET\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eyes\u003c/td\u003e\n\u003ctd\u003eRetrieve the (paginated) list of elements\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ePOST\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eno\u003c/td\u003e\n\u003ctd\u003eCreate a new element\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003e\u003cem\u003eItem operations\u003c/em\u003e\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eMethod\u003c/th\u003e\n\u003cth\u003eMandatory\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eGET\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eyes\u003c/td\u003e\n\u003ctd\u003eRetrieve element\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ePUT\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eno\u003c/td\u003e\n\u003ctd\u003eUpdate an element\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eDELETE\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eno\u003c/td\u003e\n\u003ctd\u003eDelete an element\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch2\u003eEnabling and Disabling Operations\u003c/h2\u003e\n\n\u003cp\u003eIf no operation is specified, all default CRUD operations are automatically registered. It is also possible - and recommended\nfor large projects - to define operations explicitly.\u003c/p\u003e\n\n\u003cp\u003eKeep in mind that \u003ccode\u003ecollectionOperations\u003c/code\u003e and \u003ccode\u003eitemOperations\u003c/code\u003e behave independently. For instance, if you don’t explicitly\nconfigure operations for \u003ccode\u003ecollectionOperations\u003c/code\u003e, \u003ccode\u003eGET\u003c/code\u003e and \u003ccode\u003ePOST\u003c/code\u003e operations will be automatically registered, even if you\nexplicitly configure \u003ccode\u003eitemOperations\u003c/code\u003e. The reverse is also true.\u003c/p\u003e\n\n\u003cp\u003eOperations can be configured using annotations, XML or YAML. In the following examples, we enable only the built-in operation\nfor the \u003ccode\u003eGET\u003c/code\u003e method for both \u003ccode\u003ecollectionOperations\u003c/code\u003e and \u003ccode\u003eitemOperations\u003c/code\u003e to create a readonly endpoint.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eitemOperations\u003c/code\u003e and \u003ccode\u003ecollectionOperations\u003c/code\u003e are arrays containing a list of operation. Each operation is defined by a key\ncorresponding to the name of the operation that can be anything you want and an array of properties as value.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e\u0026lt;?php\n\n// src/AppBundle/Entity/Book.php\n\nuse ApiPlatform\\Core\\Annotation\\ApiResource;\n\n/**\n * @ApiResource(collectionOperations={\u0026#34;get\u0026#34;={\u0026#34;method\u0026#34;=\u0026#34;GET\u0026#34;}}, itemOperations={\u0026#34;get\u0026#34;={\u0026#34;method\u0026#34;=\u0026#34;GET\u0026#34;}})\n */\nclass Book\n{\n    // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# src/AppBundle/Resources/config/api_resources.yml\nproduct:\n    class: \u0026#39;AppBundle\\Entity\\Book\u0026#39;\n    collectionOperations:\n        get:\n            method: \u0026#39;GET\u0026#39; # nothing more to add if we want to keep the default controller\n    itemOperations:\n        get:\n            method: \u0026#39;GET\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;!-- src/AppBundle/Resources/config/api_resources.xml --\u0026gt;\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt;\n\u0026lt;resources\u0026gt;\n    \u0026lt;resource class=\u0026#34;AppBundle\\Entity\\Book\u0026#34;\u0026gt;\n        \u0026lt;itemOperations type=\u0026#34;collection\u0026#34;\u0026gt;\n            \u0026lt;operation key=\u0026#34;get\u0026#34; method=\u0026#34;GET\u0026#34; /\u0026gt;\n        \u0026lt;/itemOperations\u0026gt;\n        \u0026lt;collectionOperations type=\u0026#34;collection\u0026#34;\u0026gt;\n            \u0026lt;operation key=\u0026#34;get\u0026#34; method=\u0026#34;GET\u0026#34; /\u0026gt;\n        \u0026lt;/collectionOperations\u0026gt;\n    \u0026lt;/resource\u0026gt;\n\u0026lt;/resources\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eAPI Platform Core is smart enough to automatically register the applicable Symfony route referencing a built-in CRUD action\njust by specifying the enabled HTTP method.\u003c/p\u003e\n\n\u003ch2\u003eConfiguring Operations\u003c/h2\u003e\n\n\u003cp\u003eThe URL, the HTTP method and the Hydra context passed to documentation generators of operations is easy to configure.\u003c/p\u003e\n\n\u003cp\u003eIn the next example, both \u003ccode\u003eGET\u003c/code\u003e and \u003ccode\u003ePUT\u003c/code\u003e operations are registered with custom URLs. Those will override the default generated\nURLs. In addition to that, we replace the Hydra context for the \u003ccode\u003ePUT\u003c/code\u003e operation.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e\u0026lt;?php\n\n// src/AppBundle/Entity/Book.php\n\nuse ApiPlatform\\Core\\Annotation\\ApiResource;\n\n/**\n * @ApiResource(itemOperations={\n *     \u0026#34;get\u0026#34;={\u0026#34;method\u0026#34;=\u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;=\u0026#34;/grimoire/{id}\u0026#34;},\n *     \u0026#34;put\u0026#34;={\u0026#34;method\u0026#34;=\u0026#34;PUT\u0026#34;, \u0026#34;path\u0026#34;=\u0026#34;/grimoire/{id}/update\u0026#34;, \u0026#34;hydra_context\u0026#34;={\u0026#34;foo\u0026#34;=\u0026#34;bar\u0026#34;}},\n * })\n */\nclass Book\n{\n    //...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# src/AppBundle/Resources/config/resources.yml\nproduct:\n    class: \u0026#39;AppBundle\\Entity\\Book\u0026#39;\n    itemOperations:\n        get:\n            method: \u0026#39;GET\u0026#39;\n            path: \u0026#39;/grimoire/{id}\u0026#39;\n        put:\n            method: \u0026#39;PUT\u0026#39;\n            path: \u0026#39;/grimoire/{id}/update\u0026#39;\n            hydra_context: { foo: \u0026#39;bar\u0026#39; }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;!-- src/Acme/BlogBundle/Resources/config/resources.xml --\u0026gt;\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt;\n\u0026lt;resources\u0026gt;\n    \u0026lt;resource class=\u0026#34;AppBundle\\Entity\\Book\u0026#34;\u0026gt;\n        \u0026lt;itemOperations type=\u0026#34;collection\u0026#34;\u0026gt;\n            \u0026lt;operation key=\u0026#34;get\u0026#34; method=\u0026#34;GET\u0026#34; /\u0026gt;\n            \u0026lt;operation key=\u0026#34;put\u0026#34; method=\u0026#34;GET\u0026#34; path=\u0026#34;/grimoire/{id}/update\u0026#34;\u0026gt;\n                \u0026lt;attribute key=\u0026#34;hydra_context\u0026#34; type=\u0026#34;collection\u0026#34;\u0026gt;\n                    \u0026lt;attribute key=\u0026#34;foo\u0026#34;\u0026gt;bar\u0026lt;/attribute\u0026gt;\n                \u0026lt;/attribute\u0026gt;\n            \u0026lt;/operation\u0026gt;\n        \u0026lt;/itemOperations\u0026gt;\n    \u0026lt;/resource\u0026gt;\n\u0026lt;/resources\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003ch2\u003eCreating Custom Operations and Controllers\u003c/h2\u003e\n\n\u003cp\u003eAPI Platform can leverage the Symfony routing system to register custom operation related to custom controllers. Such custom\ncontrollers can be any valid \u003ca href=\"http://symfony.com/doc/current/book/controller.html\"\u003eSymfony controller\u003c/a\u003e, including standard\nSymfony controllers extending the \u003ca href=\"http://api.symfony.com/3.1/Symfony/Bundle/FrameworkBundle/Controller/Controller.html\"\u003e\u003ccode\u003eSymfony\\Bundle\\FrameworkBundle\\Controller\\Controller\u003c/code\u003e\u003c/a\u003e\nhelper class.\u003c/p\u003e\n\n\u003cp\u003eHowever, API Platform recommends to use \u003cstrong\u003eaction classes\u003c/strong\u003e instead of typical Symfony controllers. Internally, API Platform\nimplements the \u003ca href=\"https://github.com/pmjones/adr\"\u003eAction-Domain-Responder\u003c/a\u003e pattern (ADR), a web-specific refinement of \u003ca href=\"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\"\u003eMVC\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote: \u003ca href=\"events.jsonld\"\u003ethe event system\u003c/a\u003e should be preferred over custom controllers when applicable.\u003c/p\u003e\n\n\u003cp\u003eThe distribution of API Platform also comes with an enhanced action system for Symfony pre-installed: \u003ca href=\"https://github.com/dunglas/DunglasActionBundle\"\u003eDunglasActionBundle\u003c/a\u003e.\n\u003cem\u003eDunglasActionBundle\u003c/em\u003e eases the implementation of the ADR pattern with Symfony and improves the developer experience.\u003c/p\u003e\n\n\u003cp\u003eIt automatically registers action classes stored in \u003ccode\u003esrc/*Bundle/Action\u003c/code\u003e and \u003ccode\u003esrc/*Bundle/Controller\u003c/code\u003e directories as autowired\nservices.\u003c/p\u003e\n\n\u003cp\u003eThanks to the \u003ca href=\"http://symfony.com/doc/current/components/dependency_injection/autowiring.html\"\u003eautowiring\u003c/a\u003e feature of the\nSymfony dependency injection container, services required by an action can be type-hinted in its controller, it will be automatically\ninstantiated and injected, without having to declare it explicitly.\u003c/p\u003e\n\n\u003cp\u003eIn the following example, the built-in \u003ccode\u003eGET\u003c/code\u003e operation is registered as well as a custom operation called \u003ccode\u003especial\u003c/code\u003e.\nThe \u003ccode\u003especial\u003c/code\u003e operation reference the Symfony route named \u003ccode\u003ebook_special\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e\u0026lt;?php\n\n// src/AppBundle/Entity/Book.php\n\nuse ApiPlatform\\Core\\Annotation\\ApiResource;\n\n/**\n * @ApiResource(itemOperations={\n *     \u0026#34;get\u0026#34;={\u0026#34;method\u0026#34;=\u0026#34;GET\u0026#34;},\n *     \u0026#34;special\u0026#34;={\u0026#34;route_name\u0026#34;=\u0026#34;book_special\u0026#34;}\n * })\n */\nclass Book\n{\n    //...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# src/AppBundle/Resources/config/resources.yml\nproduct:\n    class: \u0026#39;AppBundle\\Entity\\Book\u0026#39;\n    itemOperations:\n        get:\n            method: \u0026#39;GET\u0026#39;\n        special:\n            route_name: \u0026#39;book_special\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;!-- src/Acme/BlogBundle/Resources/config/resources.xml --\u0026gt;\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt;\n\u0026lt;resources\u0026gt;\n    \u0026lt;resource class=\u0026#34;AppBundle\\Entity\\Book\u0026#34;\u0026gt;\n        \u0026lt;itemOperations type=\u0026#34;collection\u0026#34;\u0026gt;\n            \u0026lt;operation key=\u0026#34;get\u0026#34; method=\u0026#34;GET\u0026#34; /\u0026gt;\n            \u0026lt;operation key=\u0026#34;special\u0026#34; routeName=\u0026#34;book_special\u0026#34; /\u0026gt;\n        \u0026lt;/itemOperations\u0026gt;\n    \u0026lt;/resource\u0026gt;\n\u0026lt;/resources\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003cp\u003eAPI Platform will automatically map this \u003ccode\u003especial\u003c/code\u003e operation with the route \u003ccode\u003ebook_special\u003c/code\u003e. Let’s create a custom action\nand its related route using annotations:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e\u0026lt;?php\n\n// src/AppBundle/Action/BookSpecial.php\n\nnamespace AppBundle\\Action;\n\nuse AppBundle\\Entity\\Book;\nuse Doctrine\\Common\\Persistence\\ManagerRegistry;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Method;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\nclass BookSpecial\n{\n    private $myService;\n\n    public function __construct(MyService $myService)\n    {\n        $this-\u0026gt;myService = $myService;\n    }\n\n    /**\n     * @Route(\n     *     name=\u0026#34;book_special\u0026#34;,\n     *     path=\u0026#34;/books/{id}/special\u0026#34;,\n     *     defaults={\u0026#34;_api_resource_class\u0026#34;=Book::class, \u0026#34;_api_item_operation_name\u0026#34;=\u0026#34;special\u0026#34;}\n     * )\n     * @Method(\u0026#34;PUT\u0026#34;)\n     */\n    public function __invoke($data) // API Platform retrieves the PHP entity using the data provider then (for POST and\n                                    // PUT method) deserializes user data in it. Then passes it to the action. Here $data\n                                    // is an instance of Book having the given ID. By convention, the action\u0026#39;s parameter\n                                    // must be called $data.\n    {\n        $this-\u0026gt;myService-\u0026gt;doSomething($data);\n\n        return $data; // API Platform will automatically validate, persist (if you use Doctrine) and serialize an entity\n                      // for you. If you prefer to do it yourself, return an instance of Symfony\\Component\\HttpFoundation\\Response\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis custom operation behaves exactly like the built-in operation: it returns a JSON-LD document corresponding to the id\npassed in the URL.\u003c/p\u003e\n\n\u003cp\u003eIt is mandatory to set the \u003ccode\u003e_api_resource_class\u003c/code\u003e and \u003ccode\u003e_api_item_operation_name\u003c/code\u003e (or \u003ccode\u003e_api_collection_operation_name\u003c/code\u003e for a collection\noperation) in the parameters of the route (\u003ccode\u003edefaults\u003c/code\u003e key). It allows API Platform and the Symfony routing system to hook\ntogether.\u003c/p\u003e\n\n\u003cp\u003eHere we consider that DunglasActionBundle is installed (the default when using the API Platform distribution). This\naction will be automatically registered as a service (the service name is the same as the class name: \u003ccode\u003eAppBundle\\Action\\BookSpecial\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003eAPI Platform automatically retrieve the appropriate PHP entity then then deserializes it, and for \u003ccode\u003ePOST\u003c/code\u003e and \u003ccode\u003ePUT\u003c/code\u003e requests\nupdates the entity with data provided by the user.\u003c/p\u003e\n\n\u003cp\u003eServices (\u003ccode\u003e$myService\u003c/code\u003e here) are automatically injected thanks to the autowiring feature. You can type-hint any service\nyou need and it will be autowired too.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003e__invoke\u003c/code\u003e method of the action is called when the matching route is hit. It can return either an instance of \u003ccode\u003eSymfony\\Component\\HttpFoundation\\Response\u003c/code\u003e\n(that will be displayed to the client immediately by the Symfony kernel) or, like in this example, an instance of an entity\nmapped as a resource (or a collection of instances for collection operations).\nIn this case, the entity will pass through \u003ca href=\"the-event-system.jsonld\"\u003eall built-in event listeners\u003c/a\u003e of API Platform. It will be\nautomatically validated, persisted and serialized in JSON-LD. Then the Symfony kernel will send the resulting document to\nthe client.\u003c/p\u003e\n\n\u003cp\u003eAlternatively, you can also use standard Symfony controller and YAML or XML route declarations. The following example do\nexactly the same thing than the previous example in a more Symfony-like fashion:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e\u0026lt;?php\n\n// src/AppBundle/Controller/BookController.php\n\nnamespace AppBundle\\Controller;\n\nuse AppBundle\\Entity\\Book;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\n\nclass BookController extends Controller\n{\n    public function specialAction($data)\n    {\n        return $this-\u0026gt;get(\u0026#39;my_service\u0026#39;)-\u0026gt;doSomething(Book::class, $id);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# app/config/routing.yml\n\nbook_special:\n    path: \u0026#39;/books/{id}/special\u0026#39;\n    methods:  [\u0026#39;PUT\u0026#39;]\n    defaults:\n        _controller: \u0026#39;AppBundle:Book:special\u0026#39;\n        _api_resource_class: \u0026#39;AppBundle\\Entity\\Book\u0026#39;\n        _api_item_operation_name: \u0026#39;special\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ePrevious chapter: \u003ca href=\"nelmio-api-doc.jsonld\"\u003eNelmioApiDocBundle integration\u003c/a\u003e\nNext chapter: \u003ca href=\"filters.jsonld\"\u003eFilters\u003c/a\u003e\u003c/p\u003e\n","author":[{"@type":"Person","Name":"hamza","email":"hamza@oblady.fr"},{"@type":"Person","Name":"Amrouche Hamza","email":"hamza@les-tilleuls.coop"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Alexandre Hagen","email":"hagen.discus@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Alexandre Hagen","email":"hagen.discus@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kevin Saliou","email":"kevin@saliou.name"},{"@type":"Person","Name":"Kevin Saliou","email":"kevin@saliou.name"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kevin Saliou","email":"kevin@saliou.name"}],"dateCreated":"2016-03-30T22:29:36+02:00","dateModified":"2016-09-30T11:19:24+02:00"}